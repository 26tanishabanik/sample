package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"time"
	"github.com/mattbaird/jsonpatch"
	"github.com/spf13/pflag"
	admv1beta1 "k8s.io/api/admission/v1beta1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
	"k8s.io/apiserver/pkg/server"
	"k8s.io/apiserver/pkg/server/options"
	"k8s.io/component-base/cli/globalflag"
	"k8s.io/apimachinery/pkg/runtime/schema"
	corev1 "k8s.io/api/core/v1"
	appsv1 "k8s.io/api/apps/v1"
)

// var SchemeGroupVersion = schema.GroupVersion{
// 	Group:   "tanisha.banik",
// 	Version: "v1",
// }

var SchemeGroupVersion = schema.GroupVersion{
	Group:   "apps",
	Version: "v1",
}

// type Pizza struct {
// 	v1.TypeMeta   `json:",inline"`
// 	v1.ObjectMeta `json:"metadata,omitempty"`

// 	Spec   PizzaSpec   `json:"spec,omitempty"`
// 	Status PizzaStatus `json:"status,omitempty"`
// }

// type PizzaStatus struct {
// 	Toppings  string `json:"toppings,omitempty"`
// }

// type PizzaSpec struct {
// 	Name        string `json:"name,omitempty"`
// 	Type      	string `json:"type,omitempty"`
// 	Toppings    string `json:"toppings,omitempty"`
// }

// func (in *PizzaStatus) DeepCopyInto(out *PizzaStatus) {
// 	*out = *in
// 	return
// }

// // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KlsuterStatus.
// func (in *PizzaStatus) DeepCopy() *PizzaStatus {
// 	if in == nil {
// 		return nil
// 	}
// 	out := new(PizzaStatus)
// 	in.DeepCopyInto(out)
// 	return out
// }

// // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
// func (in *Pizza) DeepCopyInto(out *Pizza) {
// 	*out = *in
// 	out.TypeMeta = in.TypeMeta
// 	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
// 	in.Spec.DeepCopyInto(&out.Spec)
// 	out.Status = in.Status
// 	return
// }

// // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Pizza.
// func (in *Pizza) DeepCopy() *Pizza {
// 	if in == nil {
// 		return nil
// 	}
// 	out := new(Pizza)
// 	in.DeepCopyInto(out)
// 	return out
// }

// // DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
// func (in *Pizza) DeepCopyObject() runtime.Object {
// 	if c := in.DeepCopy(); c != nil {
// 		return c
// 	}
// 	return nil
// }

// // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
// func (in *PizzaSpec) DeepCopyInto(out *PizzaSpec) {
// 	*out = *in
// }

// // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PizzaSpec.
// func (in *PizzaSpec) DeepCopy() *PizzaSpec {
// 	if in == nil {
// 		return nil
// 	}
// 	out := new(PizzaSpec)
// 	in.DeepCopyInto(out)
// 	return out
// }

type Options struct {
	SecureServingOptions options.SecureServingOptions
}

func (o *Options) AddFlagSet(fs *pflag.FlagSet) {
	o.SecureServingOptions.AddFlags(fs)
}

type Config struct {
	SecureServingInfo *server.SecureServingInfo
}

func (o *Options) Config() *Config {
	if err := o.SecureServingOptions.MaybeDefaultWithSelfSignedCerts("0.0.0.0", nil, nil); err != nil {
		panic(err)
	}

	c := Config{}
	o.SecureServingOptions.ApplyTo(&c.SecureServingInfo)
	return &c
}

const (
	validPizza = "val-pod"
)

func NewDefaultOptions() *Options {
	o := &Options{
		SecureServingOptions: *options.NewSecureServingOptions(),
	}
	// o.SecureServingOptions.BindAddress = net.ParseIP("0.0.0.0")
	// o.SecureServingOptions.ServerCert.CertKey.CertFile = "tls.crt"
	// o.SecureServingOptions.ServerCert.CertKey.KeyFile = "tls.key"
	// o.SecureServingOptions.ServerCert.CertDirectory = "manifests/certificates/"
	o.SecureServingOptions.BindPort = 8443
	o.SecureServingOptions.ServerCert.PairName = validPizza
	return o
}

func main() {
	options := NewDefaultOptions()

	fs := pflag.NewFlagSet(validPizza, pflag.ExitOnError)
	globalflag.AddGlobalFlags(fs, validPizza)

	options.AddFlagSet(fs)

	if err := fs.Parse(os.Args); err != nil {
		panic(err)
	}

	c := options.Config()

	mux := http.NewServeMux()
	mux.Handle("/", http.HandlerFunc(ServeKlusterValidation))
	mux.Handle("/mutate", http.HandlerFunc(ServeMutation))

	stopCh := server.SetupSignalHandler()
	ch, _, err := c.SecureServingInfo.Serve(mux, 60*time.Second, stopCh)
	if err != nil {
		fmt.Println("160: ",err)
	} else {
		<-ch
	}
}

var (
	scheme = runtime.NewScheme()
	codecs = serializer.NewCodecFactory(scheme)
)

func ServeMutation(w http.ResponseWriter, r *http.Request) {
	fmt.Println("Mutating Admission WebHook Controller reporting.......")

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		responsewriters.InternalError(w, r, err)
		fmt.Println("error reading the body: ", err.Error())
	}

	
	kindrequired := admv1beta1.SchemeGroupVersion.WithKind("AdmissionReview")
	
	var admissionReview admv1beta1.AdmissionReview
	_, _, err = codecs.UniversalDeserializer().Decode(body, &kindrequired, &admissionReview)
	if err != nil {
		fmt.Println("error converting req body to admission review type: ", err.Error())
	}

	// // get kluster spec from admission review object
	// // pizzaKind:= SchemeGroupVersion.WithKind("Pizza")
	resourceKind:= SchemeGroupVersion.WithKind("Pod")
	// // var pz Pizza
	var d appsv1.Deployment
	_, _, err = codecs.UniversalDeserializer().Decode(admissionReview.Request.Object.Raw, &resourceKind, &d)
	if err != nil {
		fmt.Println("error while getting deployment from admission review: ", err)
	}

	dep := d.DeepCopy()

	labels := dep.Spec.Template.ObjectMeta.Labels
	if _, ok := labels["env"]; ok {
        dep.ObjectMeta.Name =  dep.ObjectMeta.Name + fmt.Sprintf("-%s", labels["env"])
        fmt.Println(dep.ObjectMeta.Name)
    }
	jsonDeployment, err := json.Marshal(dep)
	if err != nil {
		fmt.Println("unable to marshal deployment: ", err)
	}
	ops, err:= jsonpatch.CreatePatch(admissionReview.Request.Object.Raw, jsonDeployment)
	if err != nil {
		fmt.Println("err in creating json patch: ", err)
	}
	patchObject, err := json.Marshal(ops)
	if err != nil {
		fmt.Println("error while converting operations to slice byte: ", err)
	}
	jsonPatchType := admv1beta1.PatchTypeJSONPatch
	response := admv1beta1.AdmissionResponse{
		UID:       admissionReview.Request.UID,
		Allowed:   true,
		PatchType: &jsonPatchType,
		Patch:     patchObject,
	}
	admissionReview.Response = &response
	
	fmt.Println("Admission Review Response: ", response)
	res, err := json.Marshal(admissionReview)
	if err != nil {
		fmt.Println("error marshalling json: ", err.Error())
	}

	_, err = w.Write(res)
	if err != nil {
		fmt.Println("error writing response to response writer: ", err.Error())
	}
}

func ServeKlusterValidation(w http.ResponseWriter, r *http.Request) {
	fmt.Println("Validating Admission WebHook Controller reporting.......")

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		responsewriters.InternalError(w, r, err)
		fmt.Println("error reading the body: ", err.Error())
	}

	
	kindrequired := admv1beta1.SchemeGroupVersion.WithKind("AdmissionReview")
	
	var admissionReview admv1beta1.AdmissionReview
	_, _, err = codecs.UniversalDeserializer().Decode(body, &kindrequired, &admissionReview)
	if err != nil {
		fmt.Println("error converting req body to admission review type: ", err.Error())
	}

	// // get kluster spec from admission review object
	// // pizzaKind:= SchemeGroupVersion.WithKind("Pizza")
	resourceKind:= SchemeGroupVersion.WithKind("Pod")
	// // var pz Pizza
	var pz corev1.Pod
	_, _, err = codecs.UniversalDeserializer().Decode(admissionReview.Request.Object.Raw, &resourceKind, &pz)
	if err != nil {
		fmt.Println("error while getting pizza type from admission review: ", err)
	}

	// fmt.Println("pod: ", pz)

	response := admv1beta1.AdmissionResponse{}
	// allow := validatePizzaOrder(pz.Spec)
	allow := validatePod(pz)
	fmt.Println("hihihihihihihi")
	
	if !allow {
		fmt.Println("********")
		response = admv1beta1.AdmissionResponse{
			UID:     admissionReview.Request.UID,
			Allowed: allow,
			Result: &metav1.Status{
				Message: fmt.Sprintf("The given pod with nginx label can't be create \n"),
			},
		}
	} else {
		fmt.Println("###########")
		response = admv1beta1.AdmissionResponse{
			UID:     admissionReview.Request.UID,
			Allowed: allow,
		}
	}

	admissionReview.Response = &response
	
	fmt.Println("Admission Review Response: ", response)
	res, err := json.Marshal(admissionReview)
	if err != nil {
		fmt.Println("error marshalling json: ", err.Error())
	}

	_, err = w.Write(res)
	if err != nil {
		fmt.Println("error writing response to response writer: ", err.Error())
	}
}

func validatePod(pod corev1.Pod) bool {
	if pod.ObjectMeta.Labels["app"] == "nginx" {
		if pod.Namespace == "default" {
			return false
		}
	}
	return true
}